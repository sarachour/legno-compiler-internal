\section{Digital to Analog Converter (DAC)}

The digital to analog converter is a hybrid digital-analog block available on
the \hcdc device~\cite{dac.h}. Figure~\ref{dac:codes} presents the complete list
of digitally settable codes in each DAC block. The digital to analog converter
accepts one digital input that is either read from memory or a lookup table, and
produces one analog output current. Figure~\ref{dac:codes} presents a complete summary of codes. 

\noindent\textbf{Location}: Each slice on the \hcdc device contains one
DAC. The DAC may read values from the lookup tables resident on slice 0 
(\tx{source} is \tx{DSRC_LUT0}) or slice 2 (\tx{source} is \tx{DSRC_LUT1})
of the same tile.


\begin{marginfigure}
    \small
    \begin{tabular}{c|c}
      code &values\\
      \hline
      \tx{enable} &\tx{bool_t}\\
      \tx{inv}    &\tx{bool_t}\\
      \tx{range}  &\tx{range_t}\\
      \tx{source} &\tx{dac_src_t}\\
      \tx{const_code} &256\\
      \tx{pmos}\caveat&8\\
      \tx{nmos}&8\\
      \tx{gain_cal}&64\\
    \end{tabular}
    \caption{DAC Values \cite{fu.h}}
    \label{dac:codes}
\end{marginfigure}
\begin{marginfigure}
    \small
    \begin{tabular}{c|c}
      code & kind \\
      \hline
      \tx{enable} & \static\\
      \tx{inv}    & \static\\
      \tx{range}  &\static\\
      \tx{source} & \static\\
      \tx{const_code} & \dynamic\\
      \tx{pmos}\caveat&\hidden\\
      \tx{nmos}&\hidden\\
      \tx{gain_cal}&\hidden\\
    \end{tabular}
    \caption{DAC Code Types\cite{fu.h}}
    \label{dac:codes}
\end{marginfigure}

\subsection{Block Function}\label{dac:blockfun}

Given a block at location \hslice{chip}{tile}{slice}, the behavior of the block
is dictated by the following relation. At a high level, the DAC block converts a
digital code to an analog current. Any behavior not covered in the algorithm
below is undefined:

\begin{algorithmic}
  \If {\tx{enable}}
    \If {\tx{source} = \tx{DSRC_MEM}}

    \State $sign(\tx{inv}) \cdot scale(\tx{range}) \cdot (\tx{const_code}-128)\cdot 128^{-1}$
    \ElsIf {\tx{source} = \tx{DSRC_LUT0}}

    \State $sign(\tx{inv}) \cdot scale(\tx{range}) \cdot (\tx{lut}\hindex{chip}{tile}{slice}{0}-128)\cdot 128^{-1}$
    \ElsIf {\tx{source} = \tx{DSRC_LUT1}}

    \State $sign(\tx{inv}) \cdot scale(\tx{range}) \cdot (\tx{lut}\hindex{chip}{tile}{slice}{2}-128)\cdot 128^{-1}$
    \EndIf
 \EndIf
\end{algorithmic}

The \tx{inv} code determines whether the output signal should be inverted or
not. The \tx{range} code scales the output signal by 1x or 10x. The \tx{range}
code may only be set to \tx{RANGE_MED} or \tx{RANGE_HIGH} for the DAC. Note
that all \static and \dynamic codes are used in the block function.

\subsection{Calibration}
The DAC block has three hidden codes. The
\tx{pmos} code is always set to $0$. The \tx{nmos} and \tx{gain_cal} codes
control the gain of the block. The DAC is calibrated using the following
algorithm:

\begin{algorithmic}
  \State{\tx{table} = \tx{make}()}
  \For{\tx{nmos} in $0...7$ }
  \For{\tx{gain_cal} in $0...63$ with stride 16 }
    \State {loss = obj(\tx{nmos},\tx{gain_cal})}
    \State {update \tx{table} loss (\tx{nmos},\tx{gain_cal})}
    \EndFor
  \EndFor

  \For{\tx{gain_cal} in $0...63$}
    \State {loss = obj(\tx{table.state.nmos},\tx{gain_cal})}
    \State {update \tx{table} loss (\tx{nmos},\tx{gain_cal})}
  \EndFor
  \State{return \tx{table.state.nmos},\tx{table.state.gain_cal}}
\end{algorithmic}

At a high level, the calibration algorithm iterates over \tx{nmos} and
\tx{gain_cal} codes and computes the loss for each combination of codes. The
loss function is computed using the objective function, \textit{obj}. Objective
functions are evaluated over a collection of 4
test points unless specified otherwise (\tx{const_code} that encodes
0.0,0.8,-0.8,0.5). The expected behavior is computed using the block function
specified in Section~\ref{dac:blockfun}. The DAC block supports three objective functions:
\begin{itemize}
\item\tx{CALIB_MINIMIZE_ERROR}: This objective function minimizes the average
  error between the observed signal and the expected behavior. 
\item\tx{CALIB_MAXIMIZE_DELTA_FIT}: This objective function minimizes the gain
  variance and magnitude bias of the block. The magnitude bias $b$ is computed
  by measuring the signal for test point $0.0$. For the nonzero test
  points, the gain is computed by taking the ratio of the observed to the
  expected value. The gain variance $\sigma^2$ is the computed by taking the
  variance over computed gains. The final returned loss is $min(\sigma,|b|)$.
  \item\tx{CALIB_FAST}: This objective function minimizes the error for test
    point $1.0$. This quickly calibrates the gain to have good gain characteristics.
\end{itemize}
