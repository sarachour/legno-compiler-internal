\chapter{Legno Quickstart}

The following quickstart walks through compiling a dynamical system program that
implements the cosine function.


\section{The Cosine Program}

The \legno compiler (\tx{legno.py}) enables developers to compile dynamical
systems down to configurations for the analog hardware. The \legno compiler
requires that dynamical systems be specified in the \tx{dynamical system
  language}, a high level language that supports writing first-order
differential equations. The \legno compiler also accepts a specification of the
target analog device, described using the Analog Device API. The \legno compiler
generates an \tx{analog device program} which implements the target dynamical
system on the specified analog device. In the following quickstart guide, we
walk through an example where we compile a dynamical system that models the
cosine function for the \hcdc analog device. 

\subsection{Dynamical System Program}
The following dynamical system program implements the cosine function. This
program can be found in \tx{progs/quickstart/cos.py}. In order for \tx{legno.py}
to find the program, the program must be placed in the \tx{progs/} directory.:
\begin{dssnippet}

from dslang.dsprog import DSProg
from dslang.dssim import DSSim,DSInfo

def dsname():
  return "cos"

def dsinfo():
  return DSInfo(name=dsname(), \
                desc="cosine",
                meas="signal",
                units="signal")
  info.nonlinear = False
  return info

def dsprog(prob):
  params = {
    'P0': 1.0,
    'V0' :0.0
  }
  prob.decl_stvar("V","(-P)","{V0}",params)
  prob.decl_stvar("P","V","{P0}",params)
  prob.emit("P","Position")
  prob.interval("P",-1.0,1.0)
  prob.interval("V",-1.0,1.0)
  prob.check()
  return prob

def dssim():
  exp = DSSim('t20')
  exp.set_sim_time(20)
  return exp
  
\end{dssnippet}

\noindent A dynamical system program must define four python functions in order to be used
by the compiler:

\begin{itemize}
\item\textbf{dsname}: This function returns the name of the program. The user
  can later refer to this program by its name during compilation.
\item\textbf{dsinfo}: This function returns detailed information about the
  program. This includes a short description of the program, the name of the
  signal being measured and the units of the signal being measured. Only one
  signal can be measured right now.
\item\textbf{dsprog}: This function returns the dynamical system associated
  with the program. The dynamical system is defined as a collection of state variable and
  function declarations. The dynamical system also contains interval annotations
  for each state variable (this defines the bounds for each variable) and which
  variable is measured. The \tx{check()} function checks to see that the system
  is bounded. 
  \item\textbf{dssim}: This function returns the simulation parameters. This
    program is to be run for 20 simulation units.  
\end{itemize}

\subsection{Breaking Down \tx{dsprog}}
In this dynamical system, the position \tx{P} corresponds to the amplitude of
the cosine function. The $V$ and $P$ variables are internal variables that are
used to model the dynamics of the system. We describe each line of the program
below:

\begin{itemize}
   \item\tx{params = \{..\}}: This statement creates a parameter map. The
     parameter map associates names with values. This is used to fill in
     parameters when defining the dynamical system. Parameters are referred to
     by their name, enclosed in curly braces (for example \tx{\{V0\}} refers to
     the parameter V0). 
   \item\tx{prob.decl_stvar("V","(-P)","{V0}",params)}: This statement defines a
     state variable $V$, whose dynamics are governed by $V' = -P$. The initial
     value of the state variable is the value of parameter V0. The last argument
     is the parameter map to use.
   \item\tx{prob.decl_stvar("P","V","{P0}",params)}: This statement defines a
     state variable $P$, whose dynamics are governed by $P' = V$. The initial
     value of the state variable is the value of parameter P0. The last argument
     is the parameter map to use. 

   \item\tx{prob.emit("P","Position")}: This statement indicates the expression
     $P$ is of interest, and should be observed. The observation is named
     \tx{Position}.
   \item\tx{prob.interval("P",-1.0,1.0)}: This statement defines the variable
     \tx{P} as falling within the bounds [-1,1]. All state variables must be
       restricted to a user-defined interval in order for the program to pass
       the well formedness check (\tx{check()} invocation).
   \item\tx{prob.interval("V",-1.0,1.0)}: This statement defines the variable
     \tx{V} as falling within the bounds[-1,1].
   \item\tx{prob.check()}: This statement checks that all the variables in the
     dynamical system are bounded. This function must pass (not trigger an error) in
     order for the program to compile successfully.
\end{itemize}



\subsection{Executing the \tx{cos} Dynamical System with a ODE Solver}

The \legno compiler supports digitally simulating dynamical systems for testing
purposes.

\begin{snippet}
  python3 legno.py --subset extended simulate cos --reference
\end{snippet}

The \tx{--reference} argument tells the compiler to perform a digital
simulation and produce reference figures. To profile the runtime of the
reference simulation, add the \tx{--runtime} argument.

Note that the \tx{--subset} argument is used to determine where to write the reference
simulation -- it does not impact the behavior of the simulation. The digital simulator
writes the plots of the state variable trajectories to the following directory:

\begin{snippet}
  outputs/legno/extended/cos/sim/ref/
\end{snippet}

\section{Compiling the \tx{cos} Program}

The following section describes how to compile the cosine program.

\subsection{Circuit Generation with \tx{LGraph}}

The \legno compiler first generates an unscaled analog device program that
implements the \tx{cos} benchmark. An analog device program (\tx{.adp})
consists of a set of block configurations and digitally programmable connections
to write to the device. This program is unscaled, meaning that the parameters
have not been changed so that dynamical system operates within the constraints
of the device. We generate the analog device program for the \tx{cos} benchmark
with the following command:

\begin{snippet}
  python3 legno.py --subset extended cos arco --abs-circuits 5 
      --conc-circuits 5 --max-circuits 1
\end{snippet}

This step of the compilation process is called the \lgraph compilation pass. The
\tx{--abs-circuits} and \tx{--conc-circuits} parameters control the search
space explored by \lgraph compilation pass. Specifying higher numbers to these
flags produces more analog device programs. The \tx{--subset} flag specifies
what subset of features to use. We choose the \tx{extended} subset because it
includes the broadest subset of tested features.

For the \tx{cos} dynamical system with the \tx{extended} set of features, all
unscaled circuits are stored in the following directory:

\begin{snippet}
  outputs/legno/extended/cos/lgraph-adp
\end{snippet}

The \lgraph command presented above produces exactly one unscaled analog device program: 

\begin{snippet}
  cos_g0x0.adp
\end{snippet}

Since the analog device program is not human readable, the compiler also
produces a graph that describes the analog device program.

\begin{snippet}
  outputs/legno/standard/cos/lgraph-adp/cos_g0x0.png
\end{snippet}

\subsubsection{Device Subsets}

The \tx{--subset} flag indicates what subset of device features to use to generate
the graph. There are three supported subsets:

\begin{itemize}
\item\tx{standard} subset: This limits the accepted modes of each block to the
  medium mode (-2 uA to 2 uA). 
\item\tx{extended} subset: This limits the accepted modes of each block to the
  high (-20 uA to 20 uA) and medium (-2 uA to 2 uA) modes.
\item\tx{unrestricted} subset: This allows all modes (low, medium and high) to
  be used. This subset involves modes that have not been thoroughly tested by us.
\end{itemize}

\subsection{Parameter Scaling with LScale}

Next, we direct the \legno compiler to scale each unscaled analog device program
in the \tx{abs-circ} directory:

\begin{snippet}
  python3 legno.py --subset extended lscale cos --search
     --model naive-max_fit --scale-circuits 1
\end{snippet}

This step of the compilation process is called the \lscale compilation pass. The
\tx{--subset} flag indicates what subset of device features to use. The
\tx{--model} argument indicates models should be used when scaling the system.
\legno supports four different modeling schemes, some of which involve delta
models. A delta model is a model that describes the physical hardware behavior:

\begin{itemize}
\item\tx{delta-max_fit}: Scale the system using delta models derived from block
  behavior, when the block is calibrated with the \tx{max_fit} strategy. The
  \tx{max_fit} calibration strategy maximizes the chances a delta model can be fit to
  account for deviations in block behavior.
\item\tx{delta-min_error}: Scale the system using delta models derived from
  block behavior, when the block is calibrated with the \tx{min_error} strategy.
  The \tx{min_error} calibration strategy minimizes the error of each block.
\item\tx{naive-max_fit} and \tx{naive-min_error}: Scale the system without delta
  models. With these schemes, the block behavior is as described in the
  specification.
\end{itemize}

We do not have any delta models for the chip yet, so we will use the \tx{naive-max_fit}
configuration. The \tx{naive_maxfit} model assumes each block delivers its
expected behavior with no deviations. The \tx{--scale-circuits} parameter
determines how many scaled programs to produce from each unscaled program.
Finally the \tx{--search} parameter tells \legno to search for the scaling
transform that produces the best signal-to-noise ratio.

For the \tx{cos} dynamical system with the \tx{extended} set of features, the
resulting scaled programs are written to the following directory:

\begin{snippet}
  outputs/legno/extended/cos/lscale-adp/
\end{snippet}

The \lscale execution presented above produces exactly one scaled analog device program: 

\begin{snippet}
  cos_g0x0_s0_ngd3.00a3.77v1.77c97.00_obsfast.adp
\end{snippet}

Since the analog device program is not human readable, the compiler
also produces graphs that visually depict the circuit each program implements.
These graphs are stored in the following directory:

\begin{snippet}
  outputs/legno/standard/cos/lscale-adp/
\end{snippet}

\subsection{Source Generation}

For each scaled analog device program, legno generates a low-level \grendel
script that executes the experiment on the analog hardware. 

\begin{snippet}
  python3 legno.py --subset extended srcgen cos --hwenv default --trials 1
\end{snippet}

This command generates a \grendel script for each scaled analog device program.
The \tx{--hwenv} parameter specifies the surrounding hardware environment
(e.g. oscilloscope). Since we're using the Sigilent 1020XE oscilloscope, we use
\tx{--hwenv default}, which contains the channel configuration described in section~\ref{setup-osc}.

\noindent\textit{no oscilloscope}: If you're not using a supported measurement device use
\tx{--hwenv noosc} -- this will still generate a trigger signal, but will not
automatically setup the measurement device.

For the \tx{cos} dynamical system with the \tx{extended} set of features, all
the \grendel scripts are stored in the following directory:

\begin{snippet}
  outputs/legno/standard/cos/grendel
\end{snippet}

Since the \tx{cos} benchmark only has one scaled circuit, only one \grendel
script is produced:

\begin{snippet}
  cos_g0x0_s0_ngd3.00a3.77v1.77c97.00_obsfast_t20_default.grendel
\end{snippet}

\section{Executing the Cosine Program with Grendel}

\subsection{Calibration}
The grendel runtime (\tx{grendel.py}) executes \tx{.grendel} scripts generated
by the \legno compiler. Before executing the script, we must calibrate any
uncalibrated blocks. The \tx{--calib-obj} argument specifies which calibration
objective to use (\tx{min_error} or \tx{max_fit}).

\noindent\textit{no oscilloscope}: If you are not using the
Sigilent 1020XE oscilloscope, include the \tx{--no-oscilloscope} flag to prevent
the runtime from attempting to communicate with the measurement device:

\begin{snippet}
python3 grendel.py calibrate --calib-obj max_fit
outputs/legno/extended/cos/grendel/cos_g0x0_s0_ngd3.00a3.77v1.77c97.00_obsfast_t20_default.grendel 
\end{snippet}
The calibration information is stored in \tx{device-state/state.db}, and reused
for subsequent executions. Any blocks that already have calibration information
in \tx{state.db} are automatically skipped. If you wish to recalibrate these
blocks, use the \tx{--recompute} flag. 
\subsection{Execution}

We can run the benchmark after all the block have been calibrated. Execute the
following command to execute the program:

\noindent\textit{no oscilloscope}: If you are not using the
Sigilent 1020XE oscilloscope, include the \tx{--no-oscilloscope} flag to prevent
the runtime from attempting to communicate with the measurement device.

\begin{snippet}
python3 grendel.py run --calib-obj max_fit outputs/legno/extended/cos/grendel/cos_g0x0_s0_ngd3.00a3.77v1.77c97.00_obsfast_t20_default.grendel
\end{snippet}

This should write the configuration to the device, and execute the cosine
function for 20 simulation units.

\subsection{Analyzing Outputs [OSC]}
This grendel script can be dispatched to the \hcdc analog device with the
following commands:

\begin{snippet}
  python3 exp_driver.py scan
  python3 exp_driver.py run
\end{snippet}

These commands execute the cosine dynamical system described in
Section~\ref{XXX}. For the \tx{cos} benchmark with the \tx{extended} set of
features, the waveforms are stored in the following directory:

\begin{snippet}
  outputs/legno/standard/cos/out-waveform
\end{snippet}

The collected waveforms can then be analyzed (compared with the expected cosine function) with the following command:

\begin{snippet}
  python3 exp_driver.py analyze
\end{snippet}

The relevant visualizations are stored in the following directory:
\begin{snippet}
  outputs/legno/standard/cos/plots
\end{snippet}

\section{Compiling the \tx{cos} Program with Delta Models}

A \textit{delta model} is an empirically derived model that describes a block's
behavior. This empirical model can be used by the compiler to compensate for any
manufacturing deviations found in the blocks.

\subsection{Getting the Delta Models}

First, we need to request a list of configured blocks to calibrate and profile.
The following command asks the compiler to attempt to scale the circuits for the
cosine benchmark using delta models: 

\begin{snippet}
  python3 legno.py --subset extended lscale cos --search
     --model delta-max_fit --scale-circuits 1
   \end{snippet}

If there are no delta models available, this command emits a list of block
configurations to calibrate and profile. This list is available in the
\tx{device-state/calibrate/max_fit.grendel} file.

After acquiring the list, we can calibrate and profile the blocks with the
following commands:

\begin{snippet}
  python3 -u grendel.py calibrate --no-oscilloscope --calib-obj max_fit \
     outputs/calibrate/max_fit.grendel
  python3 -u grendel.py profile --no-oscilloscope --calib-obj max_fit \
     outputs/calibrate/max_fit.grendel
\end{snippet}

This will update \tx{device-state/state.db} to contain both the calibration and
profiling information for each block. This step takes a long time, so get a
coffee.

After this step is finished, execute the following command to infer the delta models:

\begin{snippet}
  python3 model_builder.py infer --calib-obj max_fit --visualize
\end{snippet}

The \tx{--visualize} flag writes visualizations of the block error to \tx{device-state/MODELS}.


\subsection{Using the Delta Models}

To use the inferred delta models, simply execute the following command:
 
\begin{snippet}
  python3 legno.py --subset extended lscale cos --search
     --model delta-max_fit --scale-circuits 1
\end{snippet}

Then repeat the source generation and execution commands described above.

